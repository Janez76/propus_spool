---
import Layout from '../../layouts/Layout.astro'
---

<Layout title="FilaMan - Filaments">
  <style>
    .sortable { cursor: pointer; user-select: none; }
    .sortable:hover { background: var(--bg-hover); }
    .sortable::after { content: ' \2195'; opacity: 0.3; font-size: 0.8em; }
    .sortable.sort-asc::after { content: ' \2191'; opacity: 1; }
    .sortable.sort-desc::after { content: ' \2193'; opacity: 1; }
    .filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 16px;
      align-items: center;
    }
    .filter-bar .fm-input-search {
      flex: 1;
      min-width: 200px;
      max-width: 400px;
    }
  </style>
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
    <h1 style="font-size: 1.8rem; font-weight: 700; margin: 0; font-family: var(--font-serif);" data-i18n="filaments.title">Filaments</h1>
    <div style="display: flex; gap: 12px;">
      <a href="/filaments/colors" class="fm-btn fm-btn-outline" data-i18n="filaments.manageColors">
        Manage Colors
      </a>
      <a href="/filaments/new" class="fm-btn fm-btn-primary" data-i18n="filaments.addFilament">
        Add Filament
      </a>
    </div>
  </div>
  
  <div class="filter-bar">
    <input
      type="text"
      id="filter-search"
      class="fm-input fm-input-search"
      data-i18n-placeholder="filaments.searchPlaceholder"
      placeholder="Search designation, color, manufacturer..."
    />
    <select id="filter-manufacturer" class="fm-select" style="width: auto; min-width: 160px;">
      <option value="" data-i18n="filaments.allManufacturers">All Manufacturers</option>
    </select>
    <select id="filter-type" class="fm-select" style="width: auto; min-width: 140px;">
      <option value="" data-i18n="filaments.allTypes">All Types</option>
    </select>
    <select id="filter-color" class="fm-select" style="width: auto; min-width: 140px;">
      <option value="" data-i18n="filaments.allColors">All Colors</option>
    </select>
  </div>
  
  <div class="fm-card" style="padding: 0; overflow: hidden;">
    <table class="fm-table">
      <thead>
        <tr style="background: var(--bg-soft);">
          <th data-i18n="filaments.designation" data-sort="designation" class="sortable">Designation</th>
          <th data-i18n="filaments.colors" data-sort="colors" class="sortable">Colors</th>
          <th data-i18n="filaments.type" data-sort="type" class="sortable">Type</th>
          <th data-i18n="filaments.diameter" data-sort="diameter_mm" class="sortable">Diameter</th>
          <th data-i18n="filaments.manufacturer" data-sort="manufacturer" class="sortable">Manufacturer</th>
          <th style="text-align: right;" data-i18n="filaments.spools" data-sort="spool_count" class="sortable">Spools</th>
        </tr>
      </thead>
      <tbody id="filaments-table">
        <tr>
          <td colspan="6" style="text-align: center; color: var(--text-muted);" data-i18n="common.loading">Loading...</td>
        </tr>
      </tbody>
    </table>
  </div>
  
  <div id="pagination" style="margin-top: 16px; display: flex; justify-content: space-between; align-items: center;"></div>
  
  <script>
    import { t, initI18n } from '../../lib/i18n'
    await initI18n()

    let currentPage = 1
    const pageSize = 50
    let allFilaments: any[] = []
    let filteredFilaments: any[] = []
    let sortKey: string | null = null
    let sortDirection: 'asc' | 'desc' | null = null
    let filterManufacturerId: string | null = null

    const urlParams = new URLSearchParams(window.location.search)
    filterManufacturerId = urlParams.get('manufacturer_id')

    // Debounce timer for search input
    let searchTimeout: ReturnType<typeof setTimeout> | null = null

    function setupSortableHeaders() {
      document.querySelectorAll('th[data-sort]').forEach(th => {
        th.addEventListener('click', () => {
          const key = (th as HTMLElement).dataset.sort!
          if (sortKey === key) {
            if (sortDirection === 'asc') sortDirection = 'desc'
            else if (sortDirection === 'desc') { sortKey = null; sortDirection = null }
            else sortDirection = 'asc'
          } else {
            sortKey = key
            sortDirection = 'asc'
          }
          updateSortIndicators()
          applyFiltersAndRender()
        })
      })
    }

    function updateSortIndicators() {
      document.querySelectorAll('th[data-sort]').forEach(th => {
        const key = (th as HTMLElement).dataset.sort!
        th.classList.remove('sort-asc', 'sort-desc')
        if (sortKey === key && sortDirection) {
          th.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc')
        }
      })
    }

    function getSortValue(item: any, key: string): any {
      if (key === 'manufacturer') return item.manufacturer?.name || ''
      if (key === 'colors') return item.colors?.length || 0
      return item[key]
    }

    function sortFilaments(filaments: any[]): any[] {
      if (!sortKey || !sortDirection) return filaments
      return [...filaments].sort((a, b) => {
        const aVal = getSortValue(a, sortKey)
        const bVal = getSortValue(b, sortKey)
        let cmp = 0
        if (aVal == null && bVal == null) cmp = 0
        else if (aVal == null) cmp = 1
        else if (bVal == null) cmp = -1
        else if (typeof aVal === 'string') cmp = aVal.localeCompare(bVal)
        else cmp = aVal - bVal
        return sortDirection === 'asc' ? cmp : -cmp
      })
    }

    function getFilterValues() {
      const search = (document.getElementById('filter-search') as HTMLInputElement).value.toLowerCase().trim()
      const manufacturerId = (document.getElementById('filter-manufacturer') as HTMLSelectElement).value
      const type = (document.getElementById('filter-type') as HTMLSelectElement).value
      const color = (document.getElementById('filter-color') as HTMLSelectElement).value
      return { search, manufacturerId, type, color }
    }

    function filterFilaments(filaments: any[]): any[] {
      const { search, manufacturerId, type, color } = getFilterValues()

      return filaments.filter(f => {
        // Manufacturer filter
        if (manufacturerId && String(f.manufacturer_id) !== manufacturerId) return false

        // Type filter
        if (type && f.type !== type) return false

        // Color filter
        if (color) {
          const hasColor = f.colors?.some((fc: any) => {
            const c = fc.color
            return c && c.name === color
          })
          if (!hasColor) return false
        }

        // Text search across designation, manufacturer name, color names, type, manufacturer_color_name
        if (search) {
          const designation = (f.designation || '').toLowerCase()
          const manufacturerName = (f.manufacturer?.name || '').toLowerCase()
          const colorNames = (f.colors || []).map((fc: any) => {
            const parts: string[] = []
            if (fc.color?.name) parts.push(fc.color.name.toLowerCase())
            if (fc.display_name_override) parts.push(fc.display_name_override.toLowerCase())
            return parts.join(' ')
          }).join(' ')
          const typeName = (f.type || '').toLowerCase()
          const mfColorName = (f.manufacturer_color_name || '').toLowerCase()

          const haystack = `${designation} ${manufacturerName} ${colorNames} ${typeName} ${mfColorName}`
          if (!haystack.includes(search)) return false
        }

        return true
      })
    }

    function applyFiltersAndRender() {
      filteredFilaments = filterFilaments(allFilaments)
      currentPage = 1
      renderPage()
    }

    function renderPage() {
      const sorted = sortFilaments(filteredFilaments)
      const startIdx = (currentPage - 1) * pageSize
      const pageItems = sorted.slice(startIdx, startIdx + pageSize)
      renderFilaments(pageItems)
      renderPagination(filteredFilaments.length, currentPage)
    }

    function populateFilterDropdowns(filaments: any[]) {
      // Manufacturers
      const mfSelect = document.getElementById('filter-manufacturer') as HTMLSelectElement
      const manufacturers = new Map<string, string>()
      filaments.forEach(f => {
        if (f.manufacturer?.id && f.manufacturer?.name) {
          manufacturers.set(String(f.manufacturer.id), f.manufacturer.name)
        }
      })
      const sortedMfs = [...manufacturers.entries()].sort((a, b) => a[1].localeCompare(b[1]))
      sortedMfs.forEach(([id, name]) => {
        const opt = document.createElement('option')
        opt.value = id
        opt.textContent = name
        mfSelect.appendChild(opt)
      })

      // If URL has manufacturer_id, pre-select
      if (filterManufacturerId) {
        mfSelect.value = filterManufacturerId
      }

      // Types
      const typeSelect = document.getElementById('filter-type') as HTMLSelectElement
      const types = new Set<string>()
      filaments.forEach(f => { if (f.type) types.add(f.type) })
      const sortedTypes = [...types].sort()
      sortedTypes.forEach(type => {
        const opt = document.createElement('option')
        opt.value = type
        opt.textContent = type
        typeSelect.appendChild(opt)
      })

      // Colors
      const colorSelect = document.getElementById('filter-color') as HTMLSelectElement
      const colors = new Map<string, string>()
      filaments.forEach(f => {
        (f.colors || []).forEach((fc: any) => {
          const c = fc.color
          if (c?.name) colors.set(c.name, c.hex_code || '')
        })
      })
      const sortedColors = [...colors.entries()].sort((a, b) => a[0].localeCompare(b[0]))
      sortedColors.forEach(([name, hex]) => {
        const opt = document.createElement('option')
        opt.value = name
        opt.textContent = name
        colorSelect.appendChild(opt)
      })
    }
    
    async function loadFilaments() {
      // Load all filaments for client-side filtering
      try {
        const response = await fetch(`/api/v1/filaments?page=1&page_size=200`, {
          credentials: 'include',
        })
        
        if (!response.ok) throw new Error('Failed to fetch filaments')
        
        const data = await response.json()
        allFilaments = data.items

        // If there are more, load remaining pages
        if (data.total > 200) {
          const totalPages = Math.ceil(data.total / 200)
          for (let p = 2; p <= totalPages; p++) {
            const res = await fetch(`/api/v1/filaments?page=${p}&page_size=200`, { credentials: 'include' })
            if (res.ok) {
              const d = await res.json()
              allFilaments = allFilaments.concat(d.items)
            }
          }
        }

        populateFilterDropdowns(allFilaments)
        applyFiltersAndRender()
      } catch (error) {
        console.error('Failed to load filaments:', error)
        document.getElementById('filaments-table')!.innerHTML = `
          <tr>
            <td colspan="6" style="text-align: center; color: var(--error-text);">${t('filaments.failedLoad')}</td>
          </tr>
        `
      }
    }
    
    function renderColorDots(colors: any[]): string {
      if (!colors || colors.length === 0) return '-'
      return colors.map(fc => {
        const c = fc.color
        if (!c) return ''
        return `<span title="${fc.display_name_override || c.name}" style="display: inline-block; width: 18px; height: 18px; border-radius: 50%; background: ${c.hex_code}; border: 2px solid var(--border); vertical-align: middle; margin-right: 2px;"></span>`
      }).join('')
    }

    function renderFilaments(filaments: any[]) {
      const tbody = document.getElementById('filaments-table')!
      
      if (filaments.length === 0) {
        const { search, manufacturerId, type, color } = getFilterValues()
        const hasFilters = search || manufacturerId || type || color
        tbody.innerHTML = `
          <tr>
            <td colspan="6" style="text-align: center; color: var(--text-muted);">
              ${hasFilters ? t('filaments.noResults') : `${t('filaments.noFilaments')} <a href="/filaments/new" style="color: var(--accent);">${t('filaments.addOne')}</a>.`}
            </td>
          </tr>
        `
        return
      }
      
      tbody.innerHTML = filaments.map(f => `
        <tr style="cursor: pointer;" onclick="window.location='/filaments/${f.id}'">
          <td style="padding: 12px;">
            <div style="font-weight: 500;">${f.designation}</div>
            ${f.manufacturer_color_name ? `<div style="font-size: 0.85rem; color: var(--text-muted);">${f.manufacturer_color_name}</div>` : ''}
          </td>
          <td style="padding: 12px;">${renderColorDots(f.colors)}</td>
          <td style="padding: 12px; color: var(--text-muted);">${f.type}</td>
          <td style="padding: 12px; color: var(--text-muted);">${f.diameter_mm}mm</td>
          <td style="padding: 12px; color: var(--text-muted);">${f.manufacturer?.name || '-'}</td>
          <td style="padding: 12px; text-align: right; color: var(--text-muted);">${f.spool_count ?? 0}</td>
        </tr>
      `).join('')
    }
    
    function renderPagination(total: number, page: number) {
      const totalPages = Math.ceil(total / pageSize)
      const container = document.getElementById('pagination')!
      
      if (totalPages <= 1) {
        container.innerHTML = `<div style="font-size: 0.85rem; color: var(--text-muted);">${t('filaments.filamentCount', { count: total })}</div>`
        return
      }
      
      container.innerHTML = `
        <div style="font-size: 0.85rem; color: var(--text-muted);">
          ${t('common.showing')} ${((page - 1) * pageSize) + 1}-${Math.min(page * pageSize, total)} ${t('common.of')} ${total}
        </div>
        <div style="display: flex; gap: 8px;">
          <button 
            id="prev-btn"
            class="fm-btn fm-btn-outline"
            style="padding: 6px 14px; font-size: 0.85rem;"
            ${page <= 1 ? 'disabled' : ''}
          >
            ${t('common.previous')}
          </button>
          <button 
            id="next-btn"
            class="fm-btn fm-btn-outline"
            style="padding: 6px 14px; font-size: 0.85rem;"
            ${page >= totalPages ? 'disabled' : ''}
          >
            ${t('common.next')}
          </button>
        </div>
      `
      
      document.getElementById('prev-btn')?.addEventListener('click', () => {
        if (page > 1) {
          currentPage = page - 1
          renderPage()
        }
      })
      document.getElementById('next-btn')?.addEventListener('click', () => {
        if (page < totalPages) {
          currentPage = page + 1
          renderPage()
        }
      })
    }

    // Wire up filter events
    document.getElementById('filter-search')?.addEventListener('input', () => {
      if (searchTimeout) clearTimeout(searchTimeout)
      searchTimeout = setTimeout(() => applyFiltersAndRender(), 250)
    })
    document.getElementById('filter-manufacturer')?.addEventListener('change', () => applyFiltersAndRender())
    document.getElementById('filter-type')?.addEventListener('change', () => applyFiltersAndRender())
    document.getElementById('filter-color')?.addEventListener('change', () => applyFiltersAndRender())
    
    setupSortableHeaders()
    loadFilaments()
  </script>
</Layout>
